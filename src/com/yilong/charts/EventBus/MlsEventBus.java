package com.yilong.charts.EventBus;import android.os.Debug;import de.greenrobot.event.EventBus;import de.greenrobot.event.EventBusException;/** * @changeRecord 添加mRegisterList解决重复register的问题 by 于庭龙 2015-5-14 */public class MlsEventBus {    /**     * K线交易量左边距离     */    public final static String K_CHART_VOLUME_LEFT_AXISY_TITLE_WIDTH = "com.yilong.charts.k_chart_volume_left_axisy_title_width";    /**     * k线交易量y轴十字交叉线x轴联动     */    public final static String K_CHART_VOLUME_CROSS_X = "com.yilong.charts.k_chart_volume_cross_x";    /**     * K线成交量联动     */    public final static String K_CHART_VOLUME_VOLUEM_SCROLL_TO = "com.yilong.charts.k_chart_volume_scroll_to";    /**     *  K线交易量左边距离大于k线的宽度 回调回去     */    public final static String K_CHART_VOLUME_VOLUEM_CALLBACK_WIDTH = "com.yilong.charts.k_chart_volume_left_axisy_callback_title_width";    private static EventBus mEventBus = EventBus.getDefault();    public synchronized static void register(Object object) {        if (object == null) {//			Debug.error("MlsEventBus", "register --> object is null");            return;        }        if (!mEventBus.isRegistered(object)) {            try {                mEventBus.register(object);            } catch (EventBusException e) {            }        } else {//			Debug.error("MlsEventBus", "register --> object already registered");        }    }    public synchronized static void unregister(Object object) {        if (object == null) {//			Debug.error("MlsEventBus", "unregister --> object is null");            return;        }        if (mEventBus.isRegistered(object)) {            mEventBus.unregister(object);        } else {//			Debug.error("MlsEventBus", "unregister --> object not registered");        }    }    /**     * 事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程，而这个线程可能是UI线程。对应的函数名是onEvent。     *     * @param eventDes     * @param object     */    public synchronized static void post(String eventDes, Object object) {        mEventBus.post(new PostEvent(eventDes, object));    }    /**     * 事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的，对应的函数名是onEventMainThread。     *     * @param eventDes     * @param object     */    public synchronized static void postMainThread(String eventDes,                                                   Object object) {        mEventBus.post(new MainEvent(eventDes, object));    }    /**     * 事件的处理会在一个后台线程中执行，对应的函数名是onEventBackgroundThread，虽然名字是BackgroundThread，     * 但事件处理时间还是不应该太长，因为如果发送事件的线程是后台线程，会直接执行事件，如果当前线程是UI线程，事件会被加到一个队列中     * ，由一个线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。     *     * @param eventDes     * @param object     */    public synchronized static void postBackgroundThread(String eventDes,                                                         Object object) {        mEventBus.post(new BackEvent(eventDes, object));    }    /**     * 事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程（有线程池），但最好限制线程的数目。     *     * @param eventDes     * @param object     */    public synchronized static void postAsync(String eventDes, Object object) {        mEventBus.post(new AsyncEvent(eventDes, object));    }    private static class Event {        public String eventDes;        public Object eventObject;        public Event(String des, Object object) {            eventDes = des;            eventObject = object;        }    }    public static class PostEvent extends Event {        public PostEvent(String des, Object object) {            super(des, object);        }    }    public static class MainEvent extends Event {        public MainEvent(String des, Object object) {            super(des, object);        }    }    public static class BackEvent extends Event {        public BackEvent(String des, Object object) {            super(des, object);        }    }    public static class AsyncEvent extends Event {        public AsyncEvent(String des, Object object) {            super(des, object);        }    }    public interface OnEvent {        /**         * 使用onEvent来接收事件，那么接收事件和分发事件在一个线程中执行         *         * @param event         */        public void onEvent(PostEvent event);    }    public interface OnEventMainThread {        /**         * 使用onEventMainThread来接收事件，那么不论分发事件在哪个线程运行，接收事件永远在UI线程执行，         *         * @param event         */        public void onEventMainThread(MainEvent event);    }    public interface OnEventBackgroundThread {        /**         * 使用onEventBackgroundThread来接收事件，如果分发事件在子线程运行，那么接收事件直接在同样线程         * 运行，如果分发事件在UI线程，那么会启动一个子线程运行接收事件         *         * @param event         */        public void onEventBackgroundThread(BackEvent event);    }    public interface OnEventAsync {        /**         * 使用onEventAsync接收事件，无论分发事件在（UI或者子线程）哪个线程执行，接收都会在另外一个子线程执行         *         * @param event         */        public void onEventAsync(AsyncEvent event);    }}